1. 코드 개요

주어진 소스코드는 두 가지 주요 비동기 작업을 정의하고 있습니다:
 - chargePointAsync: 특정 사용자의 포인트를 충전하는 비동기 작업
 - usePointAsync: 특정 사용자의 포인트를 사용하는 비동기 작업

이 두 메소드는 모두 CompletableFuture를 사용하여 비동기 작업을 수행하며, supplyAsync 메소드를 통해 비동기적으로 수행됩니다. 이 방식은 작업을 메인 스레드와 별도로 실행할 수 있도록 하며, 결과는 비동기적으로 반환됩니다.

2. 동시성 제어 방식 설명
(1) CompletableFuture를 이용한 비동기 처리
CompletableFuture.supplyAsync() 메소드는 새로운 작업을 비동기적으로 실행하며, 이는 내부적으로 스레드 풀에서 작업을 처리합니다. 즉, chargePointAsync 및 usePointAsync 메소드 내의 작업이 동시에 실행될 수 있습니다.
 - supplyAsync는 기본적으로 ForkJoinPool의 공용 풀을 사용하여 병렬적으로 작업을 실행합니다. 만약 스레드 풀의 크기가 충분히 크다면, 여러 작업이 병렬로 실행되며, 메인 스레드는 이러한 비동기 작업이 완료될 때까지 블로킹되지 않습니다.

(2) 스레드 안전성 및 데이터 일관성 문제
동시성 제어에서 중요한 부분은 여러 스레드가 동시에 공유 자원에 접근할 때 발생하는 데이터 경쟁(race condition) 및 데이터 일관성 문제입니다. 이 코드에서는 데이터베이스에 접근하여 포인트를 조회하고 업데이트하는 작업이 이루어지는데, 이러한 작업은 스레드 안전성이 보장되어야 합니다.
 - userPointTable.insertOrUpdate() 및 pointHistoryTable.insert() 메소드가 데이터베이스 작업을 처리하는 것으로 보입니다. 이 메소드들이 다중 스레드 환경에서 동시 호출되는 경우 데이터 경쟁이 발생할 수 있습니다. 따라서 이러한 메소드가 동시성에 안전하도록 구현되어 있는지 확인하는 것이 중요합니다. 특히, insertOrUpdate 작업은 여러 스레드가 동시에 호출할 때 데이터가 엉킬 가능성이 있으므로, 트랜잭션 및 락(lock)을 사용하여 일관성을 보장해야 합니다.

(3) 검증 로직과 동시성
각 메소드에서는 포인트를 충전하거나 사용할 때 검증 로직을 수행합니다:
 - pointValidation.validateChargeAmount(amount)
 - pointValidation.validateMaxPoint(sumPoint, maxPoint)
 - pointValidation.validateUseAmount(userInfo.point(), amount)

이 검증 로직들은 데이터베이스에 접근하지 않고, 계산된 값을 기반으로만 수행되므로 비교적 안전하게 동작할 수 있습니다. 그러나 검증 로직과 데이터베이스에 쓰기 작업을 하는 insertOrUpdate 사이에 다른 스레드가 개입할 경우, 데이터가 일관성 있게 유지되지 않을 가능성이 있습니다.

(4) 비동기 처리의 이점과 문제점
비동기 처리의 주요 이점은 I/O 작업을 비동기적으로 처리하여 성능을 최적화하는 것입니다. 사용자는 포인트 충전 및 사용 요청을 비동기적으로 처리함으로써 시스템의 응답성을 유지할 수 있습니다. 하지만, 비동기 작업은 복잡성을 증가시키고, 특히 데이터베이스와 같이 공유 자원에 접근할 때 주의가 필요합니다.
예를 들어, chargePointAsync와 usePointAsync 메소드가 동시에 같은 사용자에게 실행될 경우, 포인트 데이터의 불일치가 발생할 수 있습니다. 이 문제를 해결하려면 추가적인 동기화 메커니즘, 예를 들어 데이터베이스 트랜잭션 또는 적절한 락이 필요합니다.

3. 동시성 제어를 위한 개선 사항 및 권장 사항

(1) 데이터베이스 트랜잭션 관리
동일한 사용자가 여러 포인트 작업을 동시에 수행할 수 있는 경우, 데이터의 일관성을 유지하기 위해 데이터베이스 트랜잭션을 적극적으로 사용해야 합니다. 예를 들어, insertOrUpdate 메소드가 트랜잭션을 통해 처리된다면, 여러 스레드가 동시에 접근할 때 데이터가 일관되게 유지될 수 있습니다.

 - 트랜잭션 경계 설정: 포인트 충전 및 사용 작업을 트랜잭션으로 감싸서 동시성 문제를 해결할 수 있습니다. 이렇게 하면 하나의 작업이 완료되기 전까지 다른 작업이 동일한 자원에 접근하지 못하도록 할 수 있습니다.

(2) 낙관적 락 또는 비관적 락 적용
동시성을 제어하기 위한 또 다른 방법으로 낙관적 락(optimistic lock) 또는 비관적 락(pessimistic lock)을 적용할 수 있습니다.

 - 낙관적 락: 데이터베이스의 버전 필드를 사용하여 충돌을 감지하고, 충돌이 발생한 경우 재시도하는 방식입니다.
 - 비관적 락: 자원을 사용하는 동안 다른 스레드의 접근을 아예 차단하는 방식으로, 충돌을 방지합니다. 이는 동시성 문제가 더 빈번하게 발생할 것으로 예상될 때 유용합니다.

(3) 스레드 풀의 설정
CompletableFuture.supplyAsync()는 기본적으로 ForkJoinPool의 공용 풀을 사용합니다. 이 스레드 풀이 너무 작거나 크게 설정되어 있지 않다면, 스레드 부족 또는 과도한 컨텍스트 스위칭이 발생할 수 있습니다. 애플리케이션의 요구 사항에 맞춰 스레드 풀의 크기를 적절하게 설정하는 것이 중요합니다.

4. 결론

이 코드에서 동시성 제어 방식은 CompletableFuture를 이용한 비동기 작업 처리로 구성되어 있으며, 주로 포인트 충전 및 사용 작업을 비동기적으로 수행함으로써 시스템 성능을 최적화하려는 시도를 보여줍니다. 그러나 동시성 환경에서 발생할 수 있는 데이터 불일치 문제를 방지하기 위해서는 트랜잭션 관리, 락 메커니즘 등의 추가적인 동시성 제어가 필요합니다.

 - 장점: 비동기적으로 처리하여 응답성을 높이고, 병렬 처리를 통해 성능을 최적화.
 - 단점: 데이터 일관성을 유지하기 위한 동기화가 부족한 경우, 데이터 무결성에 문제가 발생할 가능성.
